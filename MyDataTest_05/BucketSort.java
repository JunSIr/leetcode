package MyDataTest_05;
/*
* 桶排序分为计数排序和基数排序
* 1）它们都是不基于比较的排序
* 2)时间复杂度为O(N)，额外空间负载度O(M)
* 3)应用范围有限，需要样本的数据状况满足桶的划分
* 4）一般来讲，计数排序要求，样本是整数，且范围比较窄
* 5）一般来讲，基数排序要求，样本是10进制的正整数
* 6)一旦要求稍有升级，改写代价增加是显而易见的
* */

/*
* 排序总结收尾_稳定性
* 稳定性是指同样大小的样本再排序之后不会改变相对次序
* 对基础类型来说，稳定性毫无意义
* 对非基础类型来说，稳定性有重要意义（引用传递 举例：一个学生先排年龄，在排班级，可以保证班级排好序之后，同一个班级内部年龄是有序 工程上用于电商排序）
* 有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的

* */

/*
* 		时间复杂度	额外空间复杂度		稳定性
选择排序		O(N^2)			O(1)		无
冒泡排序		O(N^2)			O(1)		有
插入排序		O(N^2)			O(1)		有
归并排序		O(N*logN)		O(N)		有
随机快排		O(N*logN)		O(logN)		无
堆排序		O(N*logN)		O(1)		无
========================================================
计数排序		O(N)			O(M)		有
基数排序		O(N)			O(N)		有

* 面对相等时的处理态度，决定是否稳定（一般为相等不处理或默认处理左边）
* */

/* 比较与非比较
* 1）不基于比较的排序，对样本数据有严格要求，不易改写
* 2）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
* 3）基于比较的排序，时间复杂度的极限是O(N*logN)
* 4）时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的。
* 5）为了绝对的速度选快排（相同时间复杂度下，其常数时间最短）、为了省空间选堆排、为了稳定性选归并

* */

/* 常见的坑
* 1）归并排序的额外空间复杂度可以变成O(1)，“归并排序 内部缓存法”，但是将变得不再稳定。
* 2）“原地归并排序" 是垃圾贴，会让时间复杂度变成O(N^2)
* 3）快速排序稳定性改进，“01 stable sort”，但是会对样本数据要求更多（做数据范围做限制）。
* 4)在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变。时间复杂度做到O(N)，额外空间复杂度做到O(1)？01标准划分partition 快排partition也是01标准，做不到稳定性

* */

/*工程上对排序的改进（说的是Java提供的排序）
* 1)稳定性的考虑 引用用归并/基础用快排
* 2)充分利用O(N*logN)和O(N^2)排序各自的优势
* */

class CountSort{
    public void countSort(int[] arr){
        if (arr==null||arr.length < 2) return;

        /*构建与样本量相当的容器*/

        //find max value in arr
        int max = Integer.MIN_VALUE ;
        for (int i = 0; i < arr.length; i++) {
            max = Math.max(max,arr[i]) ;
        }

        //make a bucket
        int[] buckets = new int[max + 1];

        //bucket -> 词频表
        for (int i = 0; i < arr.length; i++) {
            buckets[arr[i]]++ ; //计数 有就加一
        }

        //覆盖原数组
        int i = 0 ; //原数组下标
        for (int j = 0; j < buckets.length; j++) {
            while (buckets[j]-- >0){ //条件通过后计数-1
               arr[i++] = j ;  //覆盖后i+1
            }
        }

    }
}
public class BucketSort {
    public static void main(String[] args) {
        int[] arr = {1,3,4,1} ;
        CountSort sort = new CountSort() ;
        sort.countSort(arr);
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}
